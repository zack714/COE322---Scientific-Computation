#include<iostream>
#include<complex>
using std::cout;
using std::complex;
using namespace std::complex_literals;

//make prototypes for your template functions.
template <typename T>
complex<T> f(complex<T> x);

template <typename T>
complex<T> fprime(complex<T> x);

int main(){
  complex<double> z{.5,.5};
  
  while ( true ) {
    auto fz = f(z);
    cout << "f( " << z << " ) = " << fz << '\n';
    if (std::abs(fz)<1.e-10 ) break;
    z = z - fz/fprime(z);
  }
  
  return 0;
}

//template function definitions
template <typename T>

//takes a complex version x-value entered and returns a complex double y-value 
complex<T> f(complex<T> x){
    return x*x-static_cast<complex<double>>(2);
}

//takes a complex version of an x-value and the derivate (as a complex double) 
template <typename T>
complex<T> fprime(complex<T> x){
    return static_cast<complex<double>>(2)*x;
}
